<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[lilaiqun]]></title>
  <link href="blog.lilaiqun.com/atom.xml" rel="self"/>
  <link href="blog.lilaiqun.com/"/>
  <updated>2019-10-02T15:56:29+08:00</updated>
  <id>blog.lilaiqun.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[如何保证消息不被重复消费（消费时的幂等性）]]></title>
    <link href="blog.lilaiqun.com/15700210659906.html"/>
    <updated>2019-10-02T20:57:45+08:00</updated>
    <id>blog.lilaiqun.com/15700210659906.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15700210659906/%E5%9B%BE%E7%89%87.png" alt="Kafka图示"/><br/>
<img src="media/15700210659906/15700216386343.jpg" alt=""/></p>

<p>回答这个问题，首先你别听到重复消息这个事儿，就一无所知吧，你先大概说一说可能会有哪些重复消费的问题。</p>

<p>首先就是比如rabbitmq、rocketmq、kafka，都有可能会出现消费重复消费的问题，正常。因为这问题通常不是mq自己保证的，是给你保证的。然后我们挑一个kafka来举个例子，说说怎么重复消费吧。</p>

<p>kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的offset来继续消费吧。</p>

<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接kill进程了，再重启。这会导致consumer有些消息处理了，但是没来得及提交offset，尴尬了。重启之后，少数消息会再次消费一次。</p>

<p><strong>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</strong></p>

<p>给你举个例子吧。假设你有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下已经消费过了，直接扔了，不就保留了一条数据？</p>

<p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性</p>

<p>幂等性，我通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</p>

<p>那所以第二个问题来了，怎么保证消息队列消费的幂等性？</p>

<p>其实还是得结合业务来思考，我这里给几个思路：</p>

<p>（1）比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧</p>

<p>（2）比如你是写redis，那没问题了，反正每次都是set，天然幂等性</p>

<p>（3）比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</p>

<p>还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据</p>

<p>如何保证MQ的消费是幂等性的，需要结合具体的业务来看</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何保证消息队列的高可用啊？]]></title>
    <link href="blog.lilaiqun.com/15700185588826.html"/>
    <updated>2019-10-02T20:15:58+08:00</updated>
    <id>blog.lilaiqun.com/15700185588826.html</id>
    <content type="html"><![CDATA[
<p>问题：</p>

<pre><code class="language-text">MQ的缺点：系统可用性降低。接下来围绕MQ的缺点怎么解决。

MQ的高可用性怎么保证？ 
</code></pre>

<h2 id="toc_0">1. RabbitMQ的高可用</h2>

<p>RabbitMQ比较有代表性，因为是基于主从架构</p>

<p>3种模式：<strong>单机模式，普通集群模式，镜像集群模式</strong></p>

<p>1）单机模式</p>

<p>就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式</p>

<p>2）普通集群模式</p>

<p><img src="http://images.lilaiqun.com/15700196661169.jpg" alt=""/></p>

<p>意思就是在多台机器上启动多个rabbitmq实例，每个机器启动一个。但是你创建的queue，只会放在一个rabbtimq实例上，但是每个实例都同步queue的元数据。完了你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。</p>

<p>这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</p>

<p>而且如果那个放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据。</p>

<p>所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性可言了，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个queue的读写操作。</p>

<p>3）镜像集群模式</p>

<p><img src="http://images.lilaiqun.com/15700197102596.jpg" alt=""/></p>

<p>这种模式，才是所谓的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。</p>

<p>这样的话，好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue</p>

<p>那么怎么开启这个镜像集群模式呢？我这里简单说一下，避免面试人家问你你不知道，其实很简单rabbitmq有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候可以要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>

<h2 id="toc_1">2. kakfa</h2>

<p><img src="http://images.lilaiqun.com/15700200076415.jpg" alt=""/></p>

<p>kafka一个最基本的架构认识：多个broker组成，每个broker是一个节点；你创建一个topic，这个topic可以划分为多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据。</p>

<p>这就是天然的分布式消息队列，就是说一个topic的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p>

<p>实际上rabbitmq之类的，并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论怎么玩儿，rabbitmq一个queue的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个queue的完整数据。</p>

<p>kafka 0.8以前，是没有HA机制的，就是任何一个broker宕机了，那个broker上的partition就废了，没法写也没法读，没有什么高可用性可言。</p>

<p>kafka 0.8以后，提供了HA机制，就是replica副本机制。每个partition的数据都会同步到其他机器上，形成自己的多个replica副本。然后所有replica会选举一个leader出来，那么生产和消费都跟这个leader打交道，然后其他replica就是follower。写的时候，leader会负责把数据同步到所有follower上去，读的时候就直接读leader上数据即可。只能读写leader？很简单，要是你可以随意读写每个follower，那么就要care数据一致性的问题，系统复杂度太高，很容易出问题。kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才可以提高容错性。</p>

<p>这么搞，就有所谓的高可用性了，因为如果某个broker宕机了，没事儿，那个broker上面的partition在其他机器上都有副本的，如果这上面有某个partition的leader，那么此时会重新选举一个新的leader出来，大家继续读写那个新的leader即可。这就有所谓的高可用性了。</p>

<p>写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己主动从leader来pull数据。一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有follower的ack之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p>

<p>消费的时候，只会从leader去读，但是只有一个消息已经被所有follower都同步成功返回ack的时候，这个消息才会被消费者读到。</p>

<p>实际上这块机制，讲深了，是可以非常之深入的，但是我还是回到我们这个课程的主题和定位，聚焦面试，至少你听到这里大致明白了kafka是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要遇上面试官确实是kafka高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消息队列技术选型]]></title>
    <link href="blog.lilaiqun.com/15700030762829.html"/>
    <updated>2019-10-02T15:57:56+08:00</updated>
    <id>blog.lilaiqun.com/15700030762829.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.为何使用消息队列</h2>

<p><code>解耦、异步、消峰</code></p>

<h2 id="toc_1">2.缺点</h2>

<ol>
<li>可用性降低，系统太依赖消息队列<br/></li>
<li>增加系统复杂性，发送多次消息<br/></li>
<li>一致性问题，消息发送顺序错误，导致结果错误<br/></li>
</ol>

<table>
<thead>
<tr>
<th></th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>

<tbody>
<tr>
<td>吞吐量</td>
<td>万级</td>
<td>万级</td>
<td>10万级</td>
<td>10万级</td>
</tr>
<tr>
<td>topic数量对吞吐量影响</td>
<td>万级</td>
<td>万级</td>
<td>topic可以达到几千级别，吞吐量会小幅度下降</td>
<td>topic从几十到几百个的时候，吞吐量会大幅度下降。 所以同等机器下，kafka尽量保证topic数量不要过多</td>
</tr>
<tr>
<td>时效性</td>
<td>ms级</td>
<td>微妙级，延迟最低</td>
<td>ms级</td>
<td>ms以内</td>
</tr>
<tr>
<td>可用性</td>
<td>搞，基于主从架构实现高可用</td>
<td>高，基于主从架构</td>
<td>非常高，分布式</td>
<td>非常高，分布式，一个数据多个副本，不会丢失数据</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>低概率丢失</td>
<td></td>
<td>通过参数优化配置，0丢失</td>
<td>通过参数优化配置，0丢失</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ功能极其完备</td>
<td>自带后台适合小型公司，社区活跃，基于erlang开发，开发能力强，延迟很低</td>
<td>MQ功能比较完善，还是分布式的，扩展性好</td>
<td>支持简单MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
<tr>
<td>优劣势</td>
<td>非常成熟，功能强大</td>
<td>erlang开发，性能好，延迟低</td>
<td>接口简单</td>
<td>吞吐量搞，大数据领域的日志采集</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">RabbitMq</h2>

<h2 id="toc_3">MQ</h2>

<h2 id="toc_4">Redis</h2>

<h2 id="toc_5">Kafka</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[目录接口]]></title>
    <link href="blog.lilaiqun.com/15700028122851.html"/>
    <updated>2019-10-02T15:53:32+08:00</updated>
    <id>blog.lilaiqun.com/15700028122851.html</id>
    <content type="html"><![CDATA[
<p>编译与执行<br/>
词法、语法分析基本原理<br/>
抽象语法书<br/>
Zend虚拟机</p>

<h2 id="toc_0">基本语法与扩展编写</h2>

<p><a href="#">各类基础语法的实现</a><br/>
<a href="#">手把手编写一个PHP扩展</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[**面试官：给我讲一下分库分表方案**]]></title>
    <link href="blog.lilaiqun.com/15647135075311.html"/>
    <updated>2019-08-02T10:38:27+08:00</updated>
    <id>blog.lilaiqun.com/15647135075311.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<blockquote>
<p>作者：尜尜人物<br/>
  链接：<a href="https://www.cnblogs.com/littlecharacter/p/9342129.html">https://www.cnblogs.com/littlecharacter/p/9342129.html</a></p>
</blockquote>

<ul>
<li>
<a href="#toc_0">一、数据库瓶颈</a>
<ul>
<li>
<a href="#toc_1">1、IO瓶颈</a>
</li>
<li>
<a href="#toc_2">2、CPU瓶颈</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">二、分库分表</a>
<ul>
<li>
<a href="#toc_4">1、水平分库</a>
</li>
<li>
<a href="#toc_5">2、水平分表</a>
</li>
<li>
<a href="#toc_6">3、垂直分库</a>
</li>
<li>
<a href="#toc_7">4、垂直分表</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">三、分库分表工具</a>
</li>
<li>
<a href="#toc_9">四、分库分表步骤</a>
</li>
<li>
<a href="#toc_10">五、分库分表问题</a>
<ul>
<li>
<a href="#toc_11">1. 非partition key的查询问题（水平分库分表，拆分策略为常用的hash法）</a>
</li>
<li>
<a href="#toc_12">2、非partition key跨库跨表分页查询问题（水平分库分表，拆分策略为常用的hash法）</a>
</li>
<li>
<a href="#toc_13">3、扩容问题（水平分库分表，拆分策略为常用的hash法）</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">六、分库分表总结</a>
</li>
<li>
<a href="#toc_15">七、分库分表示例</a>
</li>
</ul>


<h2 id="toc_0">一、数据库瓶颈</h2>

<p>不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务Service来看就是，可用数据库连接少甚至无连接可用。接下来就可以想象了吧（并发量、吞吐量、崩溃）。</p>

<h3 id="toc_1">1、IO瓶颈</h3>

<p>第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&gt; 分库和垂直分表。<br/>
第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt; 分库。</p>

<h3 id="toc_2">2、CPU瓶颈</h3>

<p>第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。<br/>
第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&gt; 水平分表。</p>

<h2 id="toc_3">二、分库分表</h2>

<h3 id="toc_4">1、水平分库</h3>

<p><img src="http://images.lilaiqun.com/15647137481060.jpg" alt=""/></p>

<ol>
<li><p>概念：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</p></li>
<li><p>结果：</p></li>
<li><p>每个库的结构都一样；</p></li>
<li><p>每个库的数据都不一样，没有交集；</p></li>
<li><p>所有库的并集是全量数据；</p></li>
<li><p>场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。</p></li>
<li><p>分析：库多了，io和cpu的压力自然可以成倍缓解。</p></li>
</ol>

<h3 id="toc_5">2、水平分表</h3>

<p><img src="http://images.lilaiqun.com/15647137986218.jpg" alt=""/></p>

<ol>
<li><p>概念：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</p></li>
<li><p>结果：<br/>
每个表的结构都一样；<br/>
每个表的数据都不一样，没有交集；<br/>
所有表的并集是全量数据；</p></li>
<li><p>场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</p></li>
<li><p>分析：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。</p></li>
</ol>

<h3 id="toc_6">3、垂直分库</h3>

<p><img src="http://images.lilaiqun.com/15647138213351.jpg" alt=""/></p>

<ol>
<li>概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li>
<li>结果：</li>
<li>每个库的结构都不一样；</li>
<li>每个库的数据也不一样，没有交集；</li>
<li><p>所有库的并集是全量数据；</p></li>
<li><p>场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。</p></li>
<li><p>分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。</p></li>
</ol>

<h3 id="toc_7">4、垂直分表</h3>

<p><img src="http://images.lilaiqun.com/15647138576584.jpg" alt=""/></p>

<ol>
<li><p>概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</p></li>
<li><p>结果：</p></li>
<li><p>每个表的结构都不一样；</p></li>
<li><p>每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；</p></li>
<li><p>所有表的并集是全量数据；</p></li>
<li><p>场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。</p></li>
<li><p>分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。</p></li>
</ol>

<h2 id="toc_8">三、分库分表工具</h2>

<ol>
<li>sharding-sphere：jar，前身是sharding-jdbc；</li>
<li>TDDL：jar，Taobao Distribute Data Layer；</li>
<li>Mycat：中间件。</li>
</ol>

<p>注：工具的利弊，请自行调研，官网和社区优先。</p>

<h2 id="toc_9">四、分库分表步骤</h2>

<p>根据容量（当前容量和增长量）评估分库或分表个数 -&gt; 选key（均匀）-&gt; 分表规则（hash或range等）-&gt; 执行（一般双写）-&gt; 扩容问题（尽量减少数据的移动）。</p>

<h2 id="toc_10">五、分库分表问题</h2>

<h3 id="toc_11">1. 非partition key的查询问题（水平分库分表，拆分策略为常用的hash法）</h3>

<p>除了partition key只有一个非partition key作为条件查询</p>

<p><strong>映射法</strong><br/>
<img src="http://images.lilaiqun.com/15647140231654.jpg" alt=""/></p>

<p><strong>基因法</strong><br/>
<img src="http://images.lilaiqun.com/15647140318991.jpg" alt=""/></p>

<p>注：写入时，基因法生成user_id，如图。关于xbit基因，例如要分8张表，23=8，故x取3，即3bit基因。根据user_id查询时可直接取模路由到对应的分库或分表。根据user_name查询时，先通过user_name_code生成函数生成user_name_code再对其取模路由到对应的分库或分表。id生成常用<strong>snowflake算法</strong>。</p>

<ol>
<li>端上除了partition key不止一个非partition key作为条件查询</li>
</ol>

<p><strong>映射法</strong><br/>
<img src="http://images.lilaiqun.com/15647140607030.jpg" alt=""/></p>

<p><strong>冗余法</strong><br/>
<img src="http://images.lilaiqun.com/15647140694844.jpg" alt=""/></p>

<p>注：按照order_id或buyer_id查询时路由到db_o_buyer库中，按照seller_id查询时路由到db_o_seller库中。感觉有点本末倒置！有其他好的办法吗？改变技术栈呢？</p>

<p>3、后台除了partition key还有各种非partition key组合条件查询</p>

<p><strong>NoSQL法</strong><br/>
<img src="http://images.lilaiqun.com/15647150946637.jpg" alt=""/></p>

<p><strong>冗余法</strong><br/>
<img src="http://images.lilaiqun.com/15647151004264.jpg" alt=""/></p>

<h3 id="toc_12">2、非partition key跨库跨表分页查询问题（水平分库分表，拆分策略为常用的hash法）</h3>

<p>注：用NoSQL法解决（ES等）。</p>

<h3 id="toc_13">3、扩容问题（水平分库分表，拆分策略为常用的hash法）</h3>

<p>1、水平扩容库（升级从库法<br/>
<img src="http://images.lilaiqun.com/15647151413436.jpg" alt=""/></p>

<p>注：扩容是成倍的。</p>

<p>2、水平扩容表（双写迁移法）<br/>
<img src="http://images.lilaiqun.com/15647151512396.jpg" alt=""/></p>

<p>第一步：（同步双写）应用配置双写，部署；<br/>
第二步：（同步双写）将老库中的老数据复制到新库中；<br/>
第三步：（同步双写）以老库为准校对新库中的老数据；<br/>
第四步：（同步双写）应用去掉双写，部署；</p>

<p>注：双写是通用方案。</p>

<h2 id="toc_14">六、分库分表总结</h2>

<p>分库分表，首先得知道瓶颈在哪里，然后才能合理地拆分（分库还是分表？水平还是垂直？分几个？）。且不可为了分库分表而拆分。</p>

<p>1、选key很重要，既要考虑到拆分均匀，也要考虑到非partition key的查询。<br/>
2、只要能满足需求，拆分规则越简单越好。</p>

<h2 id="toc_15">七、分库分表示例</h2>

<p>示例GitHub地址：<a href="https://github.com/littlecharacter4s/study-sharding">https://github.com/littlecharacter4s/study-sharding</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Excel制作二维码]]></title>
    <link href="blog.lilaiqun.com/15644556452076.html"/>
    <updated>2019-07-30T11:00:45+08:00</updated>
    <id>blog.lilaiqun.com/15644556452076.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p><img src="http://images.lilaiqun.com/Excel%E5%88%B6%E4%BD%9C%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt="Excel制作二维码"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三篇 Swoole WebSocket 的应用]]></title>
    <link href="blog.lilaiqun.com/15643711302986.html"/>
    <updated>2019-07-29T11:32:10+08:00</updated>
    <id>blog.lilaiqun.com/15643711302986.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<blockquote>
<p>转自：公众号 - 新亮笔记</p>
</blockquote>

<h2 id="toc_0">概述</h2>

<p>什么是 WebSocket ？</p>

<blockquote>
<p>WebSocket 是一种在单个TCP连接上进行全双工通信的协议。</p>
</blockquote>

<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</p>

<p>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>

<p>我们利用 WebSocket 进行及时通讯，今天实现一个 视频弹幕效果。</p>

<p>实现弹幕其实就和群聊类似，将消息推送给所有的客户端，只不过前端的展示所有不同。</p>

<p>本地版本：</p>

<p>后端 PHP 7.2.6、Swoole 4.3.1。</p>

<p>前端 HTML5 WebSocket、Canvas。</p>

<p>废话不多说，先看效果。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第二篇 Swoole Task 的应用]]></title>
    <link href="blog.lilaiqun.com/15639348696355.html"/>
    <updated>2019-07-24T10:21:09+08:00</updated>
    <id>blog.lilaiqun.com/15639348696355.html</id>
    <content type="html"><![CDATA[
<p>投递一个异步任务到task_worker池中。此函数是非阻塞的，执行完毕会立即返回。Worker进程可以继续处理新的请求。使用Task功能，必须先设置 task_worker_num，并且必须设置Server的onTask和onFinish事件回调函数。</p>

<span id="more"></span><!-- more -->

<blockquote>
<p>转自：公众号 - 新亮笔记</p>
</blockquote>

<h1 id="toc_0">一代码</h1>

<h2 id="toc_1">server.php</h2>

<pre><code class="language-php">&lt;?php
class Server
{
    private $serv;
    public function __construct()
    {
        $this-&gt;serv = new swoole_server(&#39;0.0.0.0&#39;, 9501;
        $this-&gt;serv-&gt;set([
            &#39;worker_num&#39; =&gt; 2,  //开启2个worker进程
            &#39;max_request&#39; =&gt; 4, //每个worker进程 max_request设置为4次
            &#39;task_worker_num&#39; =&gt; 4, //开启4个task进程
            &#39;dispatch_mode&#39; =&gt; 2,   //数据包分发策略 - 固定模式
        ]);
        $this-&gt;serv-&gt;on(&#39;Start&#39;, [$this, &#39;onStart&#39;]);
        $this-&gt;serv-&gt;on(&#39;Connect&#39;, [$this, &#39;onConnect&#39;]);
        $this-&gt;serv-&gt;on(&quot;Receive&quot;, [$this, &#39;onReceive&#39;]);
        $this-&gt;serv-&gt;on(&quot;Close&quot;, [$this, &#39;onClose&#39;]);
        $this-&gt;serv-&gt;on(&quot;Task&quot;, [$this, &#39;onTask&#39;]);
        $this-&gt;serv-&gt;on(&quot;Finish&quot;, [$this, &#39;onFinish&#39;]);
        $this-&gt;serv-&gt;start();
    }

    public function onStart($serv)
    {
        echo &quot;#### onStart ####&quot; . PHP_EOL;
        echo &quot;SWOOLE &quot; . SWOOLE_VERSION . &quot; 服务已启动&quot; . PHP_EOL;
        echo &quot;master_pid: {$serv-&gt;master_pid}&quot; . PHP_EOL;
        echo &quot;manager_pid: {$serv-&gt;manager_pid}&quot; . PHP_EOL;
        echo &quot;########&quot; . PHP_EOL . PHP_EOL;
    }

    public function onConnect($serv, $fd) {
        echo &quot;#### onConnect ####&quot; . PHP_EOL;
        echo &quot;客户端:&quot; . $fd . &quot; 已连接&quot; . PHP_EOL;
        echo &quot;########&quot; . PHP_EOL;
    }

    public function onReceive($serv, $fd, $from_id, $data) {
        echo &quot;#### onReceive ####&quot; . PHP_EOL;
        echo &quot;worker_pid: {$serv-&gt;worker_pid}&quot; . PHP_EOL;
        echo &quot;客户端:{$fd} 发来的Email:{$data}&quot; . PHP_EOL;
        $param = [
            &#39;fd&#39; =&gt; $fd,
            &#39;email&#39; =&gt; $data
        ];
        $rs = $serv-&gt;task(json_encode($param));
        if ($rs === false) {
            echo &quot;任务分配失败 Task &quot; . $rs . PHP_EOL;
        } else {
            echo &quot;任务分配成功 Task &quot; . $rs . PHP_EOL;
        }
        echo &quot;########&quot; . PHP_EOL . PHP_EOL;
    }

    public function onTask($serv, $task_id, $from_id, $data) {
        echo &quot;#### onTask ####&quot; . PHP_EOL;
        echo &quot;#{$serv-&gt;worker_id} onTask: [PID={$serv-&gt;worker_pid}]: task_id={$task_id}&quot; . PHP_EOL;
        //业务代码
        for ($i = 1; $i &lt;= 5; $i++) {
            sleep(2);
            echo &quot;Task {$task_id} 已完成了 {$i}/5 的任务&quot; . PHP_EOL;
        }
        $data_arr = json_decode($data, true);

        $serv-&gt;send($data_arr[&#39;fd&#39;], &#39;Email:&#39; . $data_arr[&#39;email&#39;] . &#39;,发送成功&#39;);
        $serv-&gt;finish($data);
        echo &quot;########&quot; . PHP_EOL;
    }

    public function onFinish($serv, $task_id, $data) {
        echo &quot;#### onFinish ####&quot; . PHP_EOL;
        echo &quot;Task {$task_id} 已完成&quot; . PHP_EOL;
        echo &quot;########&quot; . PHP_EOL;
    }

    public function onClose($serv, $fd) {
        echo &quot;Client Close.&quot; . PHP_EOL;
    }
}

$server = new Server();
</code></pre>

<p>client.php</p>

<pre><code class="language-php">&lt;?php
class Client
{   
    private $client;
    
    public function __construct() {
        $this-&gt;client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC);
        $this-&gt;client-&gt;on(&#39;Connect&#39;, [$this, &#39;onConnect&#39;]);
        $this-&gt;client-&gt;on(&#39;Receive&#39;, [$this, &#39;onReceive&#39;]);
        $this-&gt;client-&gt;on(&#39;Close&#39;, [$this, &#39;onClose&#39;]);
        $this-&gt;client-&gt;on(&#39;Error&#39;, [$this, &#39;onError&#39;]);
    }
    
    public function connect() {
        if (!$fp = $this-&gt;client-&gt;connect(&#39;127.0.0.1&#39;, 9501, 1)) {
            echo &quot;Error: {$fp-&gt;errMsg}[{$fp-&gt;errCode}]&quot; . PHP_EOL;
            return;
        }
    }

    public function onConnect($cli) {
        fwrite(STDOUT, &quot;输入Email:&quot;);
        swoole_event_add(STDIN, function(){
            fwrite(STDOUT, &quot;输入内容:&quot;);
            $msg = trim(fgets(STDIN));
            $this-&gt;send($msg);
        });
    }

    public function onReceive($cli, $data) {
        echo PHP_EOL . &quot;Received: &quot; . $data . PHP_EOL; 
    }

    public function send($data) {
        $this-&gt;client-&gt;send($data);
    }

    public function onClose($cli) {
        echo &quot;Client close connection&quot; . PHP_EOL; 
    }

    public function onError() {

    }
}


$client = new Client();
$client-&gt;connect();
</code></pre>

<h2 id="toc_2">输出</h2>

<pre><code class="language-text"># 1.启动服务端
&gt; php server.php

#### onStart ####
SWOOLE 1.10.4 服务已启动
master_pid: 4258
manager_pid: 4259
########

# 2.启动客户端
&gt; php client.php

输入Email: aaa@bb.com

# 3.服务端接收到请求

#### onConnect ####
客户端:1 已连接
########
#### onReceive ####
worker_pid: 4264
客户端:1 发来的Email:aaa@bb.com
任务分配成功 Task 0
########

#### onTask ####
#2 onTask: [PID=4260]: task_id=0
Task 0 已完成了 1/5 的任务
Task 0 已完成了 2/5 的任务
Task 0 已完成了 3/5 的任务
Task 0 已完成了 4/5 的任务
Task 0 已完成了 5/5 的任务
########
#### onFinish ####
Task 0 已完成
########

# 4.客户端收到消息

Received: Email:aaa@bb.com,发送成功
</code></pre>

<h2 id="toc_3">查看运行中的进程</h2>

<p>总共8个进程（1个master进程、1个manager进程、4个task进程、2个worker进程）</p>

<pre><code class="language-text">&gt; ps -ef|grep &#39;server.php&#39; | grep -v &#39;grep&#39;

501  4258   670   0  1:54下午 ttys003    0:06.90 php server.php
501  4259  4258   0  1:54下午 ttys003    0:00.00 php server.php
501  4260  4259   0  1:54下午 ttys003    0:00.01 php server.php
501  4261  4259   0  1:54下午 ttys003    0:00.00 php server.php
501  4262  4259   0  1:54下午 ttys003    0:00.00 php server.php
501  4263  4259   0  1:54下午 ttys003    0:00.00 php server.php
501  4264  4259   0  1:54下午 ttys003    0:00.01 php server.php
501  4265  4259   0  1:54下午 ttys003    0:00.00 php server.php
</code></pre>

<p>master进程：4258<br/>
manager进程：4259</p>

<h1 id="toc_4">二为什么执行了5次后，worker进程号发生了改变？</h1>

<p>因为我们设了置worker进程的max_request=4，一个worker进程在完成最大请求次数任务后将自动退出，进程退出会释放所有的内存和资源，这样的机制主要是解决PHP进程内存溢出的问题。</p>

<h1 id="toc_5">三当task执行任务异常，我们kill一个task进程，会再新增一个吗？</h1>

<p>会。</p>

<h1 id="toc_6">四如何设置 task_worker_num ？</h1>

<p>最大值不得超过 SWOOLE_CPU_NUM * 1000。<br/>
查看本机 CPU 核数：</p>

<pre><code class="language-text">&gt; php -a
&gt; echo swoole_cpu_num();
</code></pre>

<p>根据项目的任务量决定的，比如：1秒会产生200个任务，执行每个任务需要500ms。<br/>
想在1s中执行完成200个任务，需要100个task进程。<br/>
100 = 200/(1/0.5)</p>

<h1 id="toc_7">五如何设置 worker_num ？</h1>

<p>默认设置为本机的CPU核数，最大不得超过 SWOOLE_CPU_NUM * 1000。<br/>
比如：1个请求耗时10ms，要提供1000QPS的处理能力，那就必须配置10个进程。<br/>
10 = 0.01*1000<br/>
假设每个进程占用40M内存，10个进程就需要占用400M的内存。</p>

<p>扩展</p>

<ul>
<li>Server-&gt;taskwait</li>
<li>Server-&gt;taskWaitMulti</li>
<li>Server-&gt;taskCo</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一篇 Swoole Timer 的应用]]></title>
    <link href="blog.lilaiqun.com/15638622569963.html"/>
    <updated>2019-07-23T14:10:56+08:00</updated>
    <id>blog.lilaiqun.com/15638622569963.html</id>
    <content type="html"><![CDATA[
<p>应用场景:</p>

<ol>
<li>每天凌晨跑业务脚本</li>
<li>设计一个用WEB界面管理管理定时任务的系统。</li>
</ol>

<span id="more"></span><!-- more -->

<blockquote>
<p>转自：公众号 - 新亮笔记</p>
</blockquote>

<h2 id="toc_0">你好，Swoole</h2>

<p>PHP 的协程高性能网络通信引擎，使用 C/C++ 语言编写，提供了多种通信协议的网络服务器和客户端模块。</p>

<p>Swoole 可应用于互联网、移动通信、企业软件、网络游戏、物联网、车联网、智能家庭等领域。</p>

<p>学习 Swoole 之前，最好先了解下底层知识，比如，线程/进程、IO、TCP/IP协议 等。</p>

<p>推荐大家读一下《Linux 高性能服务器编程》这本书。</p>

<p>这篇文章主要分享 Timer 毫秒精度的定时器。</p>

<p>本地版本：PHP 7.2.6、Swoole 4.3.1。</p>

<h2 id="toc_1">Timer</h2>

<p>主要有三个方法：</p>

<p>swoole_timer_tick 间隔的时钟控制器</p>

<p>swoole_timer_after 指定的时间后执行</p>

<p>swoole_timer_clear 删除定时器</p>

<p>示例代码：</p>

<pre><code class="language-php">// 每隔3000ms触发一次
$timer_id = swoole_timer_tick(3000, function ($timer_id) {
    echo &quot;tick-&quot; . $timer_id . &quot; 3000ms-&quot; . date(&quot;Y-m-d H:i:s&quot;) . &quot;\n&quot;;
});

// 30000ms后删除定时器
swoole_timer_after(30000, function() use ($timer_id) {
    echo &quot;after 30000ms-&quot; . date(&quot;Y-m-d H:i:s&quot;) . &quot;\n&quot;;
    swoole_timer_clear($timer_id);
});
</code></pre>

<p>运行结果：</p>

<pre><code class="language-text">&gt; php timer.php

tick-1 3000ms-2019-07-23 06:23:51
tick-1 3000ms-2019-07-23 06:23:54
tick-1 3000ms-2019-07-23 06:23:57
after 30000ms-2019-07-23 06:23:57
</code></pre>

<h2 id="toc_2">应用场景</h2>

<h3 id="toc_3">一、每天凌晨跑业务脚本</h3>

<p>脚本中包括了请求其他业务方或第三方的接口，如果接口超时无响应或没有数据返回，需要进行重试。</p>

<p>重试机制为：每5隔分钟再发送一次请求，最多尝试5次，在5次内成功停止该任务，5次仍失败也停止该任务。</p>

<p>示例代码：</p>

<pre><code class="language-php">function requestUrl($url) {
    return false;
}

$apiUrl = &#39;&#39;;      // api地址
$exec_time = 0;    // 执行次数
swoole_timer_tick(6000, function($timer_id) use ($apiUrl, &amp;$exec_time) {
    $exec_time++;
    $result = requestUrl($apiUrl);
    echo date(&#39;Y-m-d H:i:s&#39;) . &quot; 执行任务中...(&quot; . $exec_time . &quot;)\n&quot;;
    if ($result) {
        // 业务代码
        swoole_timer_clear($timer_id);  // 停止定时器
        echo date(&#39;Y-m-d H:i:s&#39;) . &#39; 第（&#39; . $exec_time . &quot;）次请求接口任务执行成功\n&quot;;
    }else {
        if ($exec_time &gt;= 5) {
            swoole_timer_clear($timer_id);  // 停止定时器
            echo date(&#39;Y-m-d H:i:s&#39;) . &quot;请求接口失败，已失败5次，停止执行\n&quot;;
        } else {
            echo date(&#39;Y-m-d H:i:s&#39;) . &quot;请求接口失败，5分钟后再次尝试\n&quot;;
        }
    }
});
</code></pre>

<p>运行结果：</p>

<pre><code class="language-text">2019-07-23 08:50:08 执行任务中...(1)
2019-07-23 08:50:08请求接口失败，5分钟后再次尝试
2019-07-23 08:50:14 执行任务中...(2)
2019-07-23 08:50:14请求接口失败，5分钟后再次尝试
2019-07-23 08:50:20 执行任务中...(3)
2019-07-23 08:50:20请求接口失败，5分钟后再次尝试
2019-07-23 08:50:26 执行任务中...(4)
2019-07-23 08:50:26请求接口失败，5分钟后再次尝试
2019-07-23 08:50:32 执行任务中...(5)
2019-07-23 08:50:32请求接口失败，已失败5次，停止执行
</code></pre>

<h3 id="toc_4">二、设计一个用WEB界面管理管理定时任务的系统。</h3>

<p>Linux Crontab 最小时间粒度为分钟。</p>

<p>PHP Swoole 最小时间粒度为毫秒。</p>

<pre><code class="language-text">--------------
介绍一下时间配置

    0   1   2   3   4   5
    |   |   |   |   |   |
    |   |   |   |   |   +------ day of week (0 - 6) (Sunday=0)
    |   |   |   |   +------ month (1 - 12)
    |   |   |   +-------- day of month (1 - 31)
    |   |   +---------- hour (0 - 23)
    |   +------------ min (0 - 59)
    +-------------- sec (0-59)[可省略，如果没有0位,则最小时间粒度是分钟]
</code></pre>

<p>WEB界面管理</p>

<ul>
<li>登录、权限管理</li>
<li>任务管理（增删改查）</li>
<li>脚本机管理（机器IP地址）</li>
<li>任务日志</li>
</ul>

<p>项目地址</p>

<p><a href="https://github.com/osgochina/Donkey">https://github.com/osgochina/Donkey</a></p>

<p>三、比如，监控服务器状况。</p>

<p>参考文档<br/>
<a href="https://wiki.swoole.com/wiki/page/p-timer.html">https://wiki.swoole.com/wiki/page/p-timer.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swoole 文章汇总]]></title>
    <link href="blog.lilaiqun.com/15638621513516.html"/>
    <updated>2019-07-23T14:09:11+08:00</updated>
    <id>blog.lilaiqun.com/15638621513516.html</id>
    <content type="html"><![CDATA[
<p>第一篇：<a href="15638622569963.html">Swoole Timer 的应用</a><br/>
第二篇：<a href="15639348696355.html">第二篇 Swoole Task 的应用</a></p>

<p>第三篇：Swoole WebSocket 的应用<br/>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835004&amp;idx=1&amp;sn=d6789002ca8f919258ff21f0d8950fa9&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835004&amp;idx=1&amp;sn=d6789002ca8f919258ff21f0d8950fa9&amp;scene=21#wechat_redirect</a></p>

<span id="more"></span><!-- more -->

<p>第四篇：Swoole HTTP 的应用<br/>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835017&amp;idx=1&amp;sn=0702c96c7cf0086b8c3d8da9b6bd8160&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835017&amp;idx=1&amp;sn=0702c96c7cf0086b8c3d8da9b6bd8160&amp;scene=21#wechat_redirect</a></p>

<p>第五篇：Swoole 多协议 多端口 的应用<br/>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835038&amp;idx=1&amp;sn=9aa1dd1c76fbdfdae1c110f411c3f9e3&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835038&amp;idx=1&amp;sn=9aa1dd1c76fbdfdae1c110f411c3f9e3&amp;scene=21#wechat_redirect</a></p>

<p>第六篇：Swoole 整合成一个小框架<br/>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835048&amp;idx=1&amp;sn=dc358c5fbc91a73faf4d04b1d45e71eb&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835048&amp;idx=1&amp;sn=dc358c5fbc91a73faf4d04b1d45e71eb&amp;scene=21#wechat_redirect</a></p>

<p>第七篇：Swoole RPC 的实现<br/>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835054&amp;idx=1&amp;sn=26c27656b53923cc3f81a2aeb66c8d2b&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835054&amp;idx=1&amp;sn=26c27656b53923cc3f81a2aeb66c8d2b&amp;scene=21#wechat_redirect</a></p>

<p>第八篇：Swoole MySQL 连接池的实现<br/>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835060&amp;idx=1&amp;sn=cc3e4ae8774338b56389ec3d29fbf69d&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835060&amp;idx=1&amp;sn=cc3e4ae8774338b56389ec3d29fbf69d&amp;scene=21#wechat_redirect</a></p>

<p>第九篇：Swoole Redis 连接池的实现<br/>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835070&amp;idx=1&amp;sn=097c0972f92537ca2f8a68944b8fd8d5&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835070&amp;idx=1&amp;sn=097c0972f92537ca2f8a68944b8fd8d5&amp;scene=21#wechat_redirect</a></p>

<p>第十篇：压测 swoole_websocket_server 性能<br/>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835077&amp;idx=1&amp;sn=26e3db1a758409b7d2fdf82698094c47&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;mid=2448835077&amp;idx=1&amp;sn=26e3db1a758409b7d2fdf82698094c47&amp;scene=21#wechat_redirect</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出gRPC]]></title>
    <link href="blog.lilaiqun.com/15633722743311.html"/>
    <updated>2019-07-17T22:04:34+08:00</updated>
    <id>blog.lilaiqun.com/15633722743311.html</id>
    <content type="html"><![CDATA[
<p>详解gRPC运作机制与原理<br/>
李林锋<br/>
《Netty 权威指南》、《分布式服务框架原理与实践》作者。</p>

<span id="more"></span><!-- more -->

<ul>
<li>01 | gRPC 入门及服务端创建和调用原理</li>
<li>02 | 客户端创建和调用原理</li>
<li>03 | gRPC 线程模型分析</li>
<li>04 | gRPC 服务调用原理</li>
<li>05 | gRPC 安全性设计</li>
<li>06 | gRPC 序列化机制</li>
</ul>

<p>添加微信获取课程<br/>
<img src="http://images.lilaiqun.com/WechatQR.jpeg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[算法面试通关40讲]]></title>
    <link href="blog.lilaiqun.com/15633721987028.html"/>
    <updated>2019-07-17T22:03:18+08:00</updated>
    <id>blog.lilaiqun.com/15633721987028.html</id>
    <content type="html"><![CDATA[
<p>前Facebook工程师带你吃透大厂面试题<br/>
覃超<br/>
Sophon Tech创始人，前Facebook工程师，卡内基梅隆大学计算机硕士</p>

<span id="more"></span><!-- more -->

<p><img src="http://images.lilaiqun.com/15633722288813.jpg" alt=""/></p>

<p>添加微信获取课程<br/>
<img src="http://images.lilaiqun.com/WechatQR.jpeg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux性能优化实战]]></title>
    <link href="blog.lilaiqun.com/15633721257544.html"/>
    <updated>2019-07-17T22:02:05+08:00</updated>
    <id>blog.lilaiqun.com/15633721257544.html</id>
    <content type="html"><![CDATA[
<p>10分钟帮你找到系统瓶颈<br/>
倪朋飞<br/>
微软资深工程师，Kubernetes项目维护者</p>

<span id="more"></span><!-- more -->

<p><img src="http://images.lilaiqun.com/15633721550369.jpg" alt=""/></p>

<p>添加微信获取课程<br/>
<img src="http://images.lilaiqun.com/WechatQR.jpeg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据分析实战45讲]]></title>
    <link href="blog.lilaiqun.com/15632653643382.html"/>
    <updated>2019-07-16T16:22:44+08:00</updated>
    <id>blog.lilaiqun.com/15632653643382.html</id>
    <content type="html"><![CDATA[
<p>即学即用的数据分析入门课</p>

<blockquote>
<p>陈旸<br/>
清华大学计算机博士</p>
</blockquote>

<span id="more"></span><!-- more -->

<p><img src="http://images.lilaiqun.com/15632653939858.jpg" alt=""/></p>

<p>添加微信获取课程<br/>
<img src="http://images.lilaiqun.com/WechatQR.jpeg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL实战45讲]]></title>
    <link href="blog.lilaiqun.com/15632650684753.html"/>
    <updated>2019-07-16T16:17:48+08:00</updated>
    <id>blog.lilaiqun.com/15632650684753.html</id>
    <content type="html"><![CDATA[
<p>从原理到实战，丁奇带你搞懂MySQL</p>

<blockquote>
<p>林晓斌<br/>
网名丁奇，前阿里资深技术专家</p>
</blockquote>

<span id="more"></span><!-- more -->

<p><img src="http://images.lilaiqun.com/15632653017587.jpg" alt=""/></p>

<p>添加微信获取课程<br/>
<img src="http://images.lilaiqun.com/WechatQR.jpeg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从0开始学大数据]]></title>
    <link href="blog.lilaiqun.com/15632623449194.html"/>
    <updated>2019-07-16T15:32:24+08:00</updated>
    <id>blog.lilaiqun.com/15632623449194.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>李智慧<br/>
同程艺龙交通首席架构师，前Intel大数据架构师，《大型网站技术架构》作者</p>
</blockquote>

<span id="more"></span><!-- more -->

<p><img src="http://images.lilaiqun.com/15632623473232.jpg" alt=""/></p>

<p>添加微信获取课程<br/>
<img src="http://images.lilaiqun.com/WechatQR.jpeg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贫穷的本质]]></title>
    <link href="blog.lilaiqun.com/15632618037754.html"/>
    <updated>2019-07-16T15:23:23+08:00</updated>
    <id>blog.lilaiqun.com/15632618037754.html</id>
    <content type="html"><![CDATA[
<p>关于本书作者：</p>

<blockquote>
<p>阿比吉特·班纳吉和埃斯特·迪弗洛，两人都是美国麻省理工学院的教授，班纳吉是麻省理工学院福特基金会国际经济学教授，曾任世界银行荣誉顾问。迪弗洛麻省理工学院经济系阿卜杜勒·拉蒂夫·贾米尔扶贫与发展经济学教授，2009年被《经济学人》杂志评为“八大杰出经济学家”之一。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>关于本书：</p>

<blockquote>
<p>本书曾获《金融时报》评选的“年度最佳图书奖”。<br/>
《贫穷的本质》是两位作者历经15年实证调查写成，它主要讨论的是贫穷的原因，以及对主流“扶贫观念”的反思。</p>
</blockquote>

<p><strong>穷人为什么这么穷？</strong></p>

<p><strong>一、穷人缺乏有效的避险工具</strong></p>

<ol>
<li>穷人会生一堆孩子，但生孩子不是观念落后，而是一种理性思考，因为穷人所在的国家往往没有社会保障体系，想规避养老和医疗风险，只能依靠自己的子女，但是子女身上不确定性太多，或者早夭，或者关系不好，或者没能力养老，穷人往往采取多生几个的策略，尽量规避风险。</li>
<li>婚姻也是一种规避风险的方式。印度的穷人一般会将自己的女儿嫁到不远不近的村庄，如果两个村子太近，气候完全一样，你这里发洪水，我这个也发洪水，谁也帮不上谁。两个村子隔开一段距离，气候条件就不一样了，遇到灾险，不至于全军覆没，还可互相帮助。</li>
<li>穷人借高利贷，是因为正规金融体系排斥穷人。高利贷的利息高是由风险定价决定的，并非剥削。穷人使用高利贷规避可能出现的灾病风险，几乎不可能脱贫，因为高利贷的利息成本和穷人的违约率“一损俱损”。</li>
</ol>

<p><strong>二、穷人不做远期规划</strong></p>

<ol>
<li><p>绝大多数地方的穷人对教育很不重视，即便很多慈善组织跑来给他们建立学校、普及教育的好处，家长们积极性也不高。因为穷人并不确定10个儿女里，哪个可能会给他养老，而偏偏教育是个长期投入，要好多年后才能看到成效。让穷人赌一个遥遥无期的结果，要冒太大风险。他们宁愿把钱花到马上就能见效的事情上，比如买点食物，改善一下伙食。</p></li>
<li><p>穷人是很穷，连填饱肚子都有困难，如果他们得到慈善机构的粮食补助，但穷人会拿补贴的钱去买电视机、收音机。和我们的直觉相反，对穷人来说，他首要选择不是填饱肚子，而是让自己毫无希望的贫穷生活少一点儿乏味。</p></li>
<li><p>人的压力和一种叫皮质醇激素水平相关，皮质醇水平越高就代表压力越大。穷人长期处于生存压力中，皮质醇水平很高，这会影响大脑的部分区域，比如前额皮质、类扁桃体等，这些是认知功能的重要区域。所以，长期处于压力之下的穷人，他们不太可能会做出理智的决定、长远的决策。</p></li>
</ol>

<p><strong>三、穷人充满执拗和偏见</strong></p>

<ol>
<li><p>穷人会把自己的大部分钱花在健康上，但他们的花销很不科学。比如，穷人特别喜欢用抗生素，而且经常会做一些为时已晚的外科手术。也就是说，穷人平常不会花点小钱预防疾病，而等到健康真的出了大问题了，他们又不惜借钱来拼命治疗。穷人相信一种理论，他们觉得药物直接输送至血液是很重要的，所以，他们觉得输液比口服药物更有效，会大量的使用抗生素。</p></li>
<li><p>说服穷人父母们让孩子来打疫苗是一件非常困难的事儿，因为他们不相信疫苗，并不是所有没接种的孩子都会感染麻疹，但这事儿在家长们看来就有问题了，接种的和没接种的都没得病啊，说明疫苗没用。接种一种疫苗只能预防一种疾病，其他的疾病可预防不了，受过教育的父母就觉得自己受了骗，以后再也不让孩子打疫苗了。</p></li>
</ol>

<p><strong>四、我们和穷人思维上没有本质区别</strong></p>

<ol>
<li><p>很多人一辈子省吃俭用，不办健身卡、不舍得体检，真的检查出大病了，哪怕是晚期，全家人都会四处举债借钱，做各种昂贵的手术，只为延长哪怕几个月的生命。</p></li>
<li><p>很多年轻人沉迷于网络游戏，荒废工作学习，因为游戏的设计者利用了心理学上刺激反馈的概念，这种机制给你一个短期刺激，做一个动作就会有相应的反馈出现，而工作学习是个苦活，还要长期坚持才能见效，不如游戏里即时刺激有趣。</p></li>
<li><p>在不懂的事情上，我们一样有偏见，在网上慷慨激昂的反对转基因食品的人，并不清楚转基因到底是什么，只是凭感觉认为人工的东西不如天然。去医院看病，明明看不懂，但主管会觉得医生肯定做不必要的检查了，在我们认知水平达不到的领域，我们也喜欢按直觉和情绪去理解很多东西。</p></li>
</ol>

<p><strong>总结一下：</strong><br/>
穷人之所以穷是因为，第一，避险手段太落后，第二，他们只顾眼前，不做任何长远规划，第三，因为认知水平的局限，他们对不懂的东西有太多偏见。其实我们和穷人并没有什么本质的区别，他们犯的错误，我们也在犯。</p>

<p>金句：</p>

<p>穷人会听到这样的声音，“你永远都买不起那台电冰箱，还是喝杯茶吧……”。结果形成了一个恶性循环：对于穷人来说，存钱的吸引力更小，因为在他们看来，目标太遥远了，而且他们知道一路上会遇到很多诱惑。不过，如果不存钱，他们会一直穷下去。放弃短期目标，追求长期目标，需要人的自我控制能力，但自我控制就像一块肌肉：我们用这块肌肉时就会感到劳累，因此穷人很难存下钱也就不足为怪了。</p>

<p>对于生活在安全而干净的家中、躺在舒适沙发上的我们来说，痛斥家长式作风的危害、告诉自己该为自己的生活负责是轻而易举的。对于我们这些生活在富裕世界的人来说，我们目前不正是这种家长式作风的永久受益者么？我们深深扎根于这一体系而浑然不觉。这个体系不仅可以将我们照顾得更好，而且我们也不需要去思考生活中的其他问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设为首页 收藏本站]]></title>
    <link href="blog.lilaiqun.com/15632615375886.html"/>
    <updated>2019-07-16T15:18:57+08:00</updated>
    <id>blog.lilaiqun.com/15632615375886.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-text">&lt;script&gt;
    //设为首页
    function SetHome(obj,url){
        try{
            obj.style.behavior=&#39;url(#default#homepage)&#39;;
            obj.setHomePage(url);
        }catch(e){
            if(window.netscape){
                try{
                    netscape.security.PrivilegeManager.enablePrivilege(&quot;UniversalXPConnect&quot;);
                }catch(e){
                    alert(&quot;抱歉，此操作被浏览器拒绝！\n\n请在浏览器地址栏输入“about:config”并回车然后将[signed.applets.codebase_principal_support]设置为&#39;true&#39;&quot;);
                }
            }else{
                alert(&quot;抱歉，您所使用的浏览器无法完成此操作。\n\n您需要手动将【&quot;+url+&quot;】设置为首页。&quot;);
            }
        }
    }

    //收藏本站
    function AddFavorite(title, url) {
        try {
            window.external.addFavorite(url, title);
        }
        catch (e) {
            try {
                window.sidebar.addPanel(title, url, &quot;&quot;);
            }
            catch (e) {
                alert(&quot;抱歉，您所使用的浏览器无法完成此操作。\n\n加入收藏失败，请进入新网站后使用Ctrl+D进行添加&quot;);
            }
        }
    }
&lt;/script&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Typora 0.9.9.7.6]]></title>
    <link href="blog.lilaiqun.com/15632578058179.html"/>
    <updated>2019-07-16T14:16:45+08:00</updated>
    <id>blog.lilaiqun.com/15632578058179.html</id>
    <content type="html"><![CDATA[
<p><code>极简Markdown编辑器</code>  这款软件可以直观的看到源部分和预览部分，非常的方便。<br/>
<span id="more"></span><!-- more --></p>

<p><img src="http://images.lilaiqun.com/15632579039227.jpg" alt=""/><br/>
<img src="http://images.lilaiqun.com/15632579172204.jpg" alt=""/><br/>
<img src="http://images.lilaiqun.com/15632579242476.jpg" alt=""/><br/>
<img src="http://images.lilaiqun.com/15632579328177.jpg" alt=""/></p>

<h2 id="toc_0">应用介绍</h2>

<p>Typora是一个功能强大的Markdown编辑器，使用是GFM风格。</p>

<h2 id="toc_1">实时预览</h2>

<p>不像大多数MarkDown编辑器，也不会其窗口拆分为源部分和预览部分。相反，它让你预览您的作品在同一窗口，实时。</p>

<h2 id="toc_2">本机在OS X</h2>

<p>Integerate与Mac系统。支持自动保存，版本控制，拼写检查等。</p>

<h2 id="toc_3">快捷键</h2>

<p>使用快捷键来更改文本格式，轻松。</p>

]]></content>
  </entry>
  
</feed>
